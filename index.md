# About Me #

A software worker, at the dawn of the third industrial revolution. 
Try to make it philosophical, and add some jazz.

# A bullet-list #

* **in 2018 decent languages are Strongly Statically typed**
* types are cool
* **Domain Driven Design** is a practice of logic and (hidden) math in the everyday
* O.O. is ok
* F.P. is nice
* **Algebraic Data Types** (ADT) with sum (union) and product (cartesian product) are cooler
* [**reactive**](https://www.reactivemanifesto.org/)
* curry howard isomorphism is cool
* cathegory theory is cool
* basic CS : data structures and algorithms, compilers, operating systems, cryptography, network
* the unix CLI is still one of the coolest, go git bash.
* **humans** write and read code, machines only executes it (except some still rare exceptions of experimental AIs)
* composition over inheritance
* average human brains have limited processing and understanding capabilities, you (and I) are one of those humans
* DRY : dont repeat yourself (but mind different things can be very similar!)
* KISS: keep it simple stupid (sometime's hard)
* logs are vital, must be meaningful, must be available
* type providers are super cool
* side effects are either memory mutation or I/O  minimize memory mutation.
* when there's I/O take advantage of interrupts (dont wait!) async all the way.
* **concurrency flavours**: thread (OS/CLR) -> task (future) -> async (fakesync : almost as if it was sync) -> observables (in-process execution transparency: scheduler takes care) -> concrete actors (akka) (error kernel, configurable deployment/scaling) -> virtual actors (olreans) (cluster-wise execution transparency)
* a unit is the most reasonable portion of software containing logic (for human brains)
* a unit test is a test covering the conditional and branching logic of a unit
* dependency injection is ok 
* dynamic and object datatype are either evil or madness (but is fine if you need them for reflection)
* di containers: + flexibility, - compiletime check
* object relational mapper: micro orm are cool, dapper is nice, Sql type provider is cooler
* **REST** : Representational State Transfer means accessing and quering resources (and GRAPHQL?)
* swagger is nice for openapi endpoints (and fsharp type provider is awesome)
* **HATEOS** : Hypermedia As The Engine Of Application State, basically meaning that the server response contains (hyper) "links" needed by the client to query and interact with the resource (media).
* use the **polymorphism** you have! interface inheritance and composition, generic polymorhism, sum types (ADT)
* usually separating data from behaviour is a good habit (fp), and makes up for good documentation
* mind observables, be asynchronous, be compositional, be elastic, be reactive.
* factory pattern does not solve all your problems
* most of OOP code is POO (procedural old code).

## Explorations

* **actor model** is the only known acceptable and working O.O. paradygm for distributed/concurrent systems.
* [semantic web, RDF, ontologies, SPARQL (there's a liteq fsharp type provider!)](https://en.wikipedia.org/wiki/SPARQL)
* graph databases - neo4j
* mbrace vs labda functions (cloud processing)
* blockchain is a linked list of hash pointers, plus merkle trees. 
* bitcoin, ethereum, hyperledger... platforms for distributed application in trustless networks scenarios.
* **Inter Planetary File System** (IPFS, a challenge to HTTP)
